<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sankey Avanzado con Nodos Contra√≠bles</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7fa;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #2c3e50;
        }

        #sankey-canvas {
            position: relative;
            width: 100%;
            height: 80vh;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            box-sizing: border-box;
            cursor: default;
        }

        /* --- ESTILOS PARA NODOS Y GRUPOS --- */
        .sankey-node, .sankey-group-node {
            position: absolute;
            border-radius: 8px;
            cursor: move;
            user-select: none;
            transition: all 0.4s ease;
        }

        .sankey-node {
            width: 180px; /* M√°s compacto */
            padding: 4px 8px; /* Menos padding */
            display: flex;
            align-items: center;
            gap: 6px; /* Menos espacio */
            z-index: 10;
            background-color: #fdfdfd;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* El grupo expandido es un puro contenedor visual */
        .sankey-group-node {
            padding: 20px;
            padding-top: 50px;
            background-color: transparent;
            border: 2px dashed #adb5bd;
            box-shadow: none;
            z-index: 1;
        }

        .sankey-group-node:hover, .sankey-node:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .sankey-group-node:hover {
             box-shadow: none;
        }


        .sankey-node.dragging, .sankey-group-node.dragging {
            z-index: 1000;
            cursor: grabbing;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }
        
        .group-title {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 1.2em;
            font-weight: 600;
            color: #34495e;
        }
        .group-total-value {
             position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.2em;
            font-weight: 600;
            color: #3498db;
        }

        .node-icon { font-size: 18px; } /* Icono m√°s peque√±o */
        .node-info { flex-grow: 1; }
        .node-label { font-weight: 600; font-size: 12px; color: #34495e; } /* Texto m√°s peque√±o */
        .node-value { font-size: 10px; color: #555; } /* Texto m√°s peque√±o */

        #sankey-svg-links {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .sankey-link, .particle {
            transition: opacity 0.4s ease;
        }

        .sankey-link { fill: none; stroke: #e0e0e0; stroke-opacity: 0.7; }
        .particle { fill-opacity: 0.9; stroke: white; stroke-width: 0.5px; }

        /* --- L√ìGICA DE ENFOQUE --- */
        .faded {
            opacity: 0.1 !important;
        }
        .focused {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(44, 62, 80, 0.25);
        }

        /* --- BOT√ìN Y MEN√ö --- */
        .node-add-button {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            line-height: 24px;
            font-weight: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            text-shadow: 0 0 3px rgba(0,0,0,0.4);
            z-index: 20;
        }

        .sankey-node:hover .node-add-button, .sankey-group-node:hover .node-add-button {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) scale(1.1);
        }

        .node-popup-menu {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            padding: 5px;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
        }

        .node-popup-menu.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(10px);
        }

        .popup-item { padding: 8px 15px; cursor: pointer; font-size: 14px; color: #333; border-radius: 4px; white-space: nowrap; }
        .popup-item:hover { background-color: #f5f5f5; }

    </style>
</head>
<body>

    <header>
        <h1>Sankey con Nodos Contra√≠bles y Foco de Flujo</h1>
        <p>Haz clic en un nodo para enfocar su flujo. Usa el bot√≥n '+' en el grupo para expandir o contraer.</p>
    </header>

    <div id="sankey-canvas">
        <svg id="sankey-svg-links"></svg>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('sankey-canvas');
            const svgLinks = document.getElementById('sankey-svg-links');
            const SVG_NS = "http://www.w3.org/2000/svg";
            let focusedNodeId = null;

            const nodesData = [
                { id: 'prod-group', type: 'group', label: 'Producci√≥n', color: '#2c3e50', x: 30, y: 30, isCollapsed: false },
                { id: 'carbon', type: 'node', parent: 'prod-group', label: 'Carb√≥n mineral', value: 367.32, icon: '‚ö´', color: '#795548' },
                { id: 'petroleo', type: 'node', parent: 'prod-group', label: 'Petr√≥leo crudo', value: 5756.50, icon: 'üõ¢Ô∏è', color: '#212121' },
                { id: 'condensados', type: 'node', parent: 'prod-group', label: 'Condensados', value: 92.51, icon: 'üíß', color: '#BDBDBD' },
                { id: 'gas', type: 'node', parent: 'prod-group', label: 'Gas natural', value: 2803.41, icon: 'üí®', color: '#03A9F4' },
                { id: 'nuclear', type: 'node', parent: 'prod-group', label: 'Energ√≠a Nuclear', value: 63.94, icon: '‚öõÔ∏è', color: '#F44336' },
                { id: 'hidro', type: 'node', parent: 'prod-group', label: 'Energ√≠a Hidr√°ulica', value: 140.65, icon: 'üåä', color: '#00BCD4' },
                { id: 'geo', type: 'node', parent: 'prod-group', label: 'Geoenerg√≠a', value: 28.76, icon: 'üåã', color: '#FF5722' },
                { id: 'solar', type: 'node', parent: 'prod-group', label: 'Energ√≠a solar', value: 14.71, icon: '‚òÄÔ∏è', color: '#FFC107' },
                { id: 'eolica', type: 'node', parent: 'prod-group', label: 'Energ√≠a e√≥lica', value: 4.72, icon: 'üå¨Ô∏è', color: '#81D4FA' },
                { id: 'bagazo', type: 'node', parent: 'prod-group', label: 'Bagazo de ca√±a', value: 99.08, icon: 'üåø', color: '#8BC34A' },
                { id: 'lena', type: 'node', parent: 'prod-group', label: 'Le√±a', value: 138.37, icon: 'ü™µ', color: '#A1887F' },
                { id: 'biogas', type: 'node', parent: 'prod-group', label: 'Biog√°s', value: 1.30, icon: '‚ôªÔ∏è', color: '#4CAF50' },
                { id: 'transformacion', type: 'node', label: 'Transformaci√≥n', icon: '‚öôÔ∏è', color: '#f39c12', x: 550, y: 300 },
                { id: 'consumo', type: 'node', label: 'Consumo Final', icon: ' ', color: '#e74c3c', x: 950, y: 200 },
                { id: 'exportacion', type: 'node', label: 'Exportaci√≥n', icon: '‚úàÔ∏è', color: '#9b59b6', x: 950, y: 400 }
            ];

            const linksData = [
                ...nodesData.filter(n => n.parent === 'prod-group').map(n => ({ source: n.id, target: 'transformacion', value: n.value })),
                { source: 'transformacion', target: 'consumo', value: 7000 },
                { source: 'transformacion', target: 'exportacion', value: 2400 }
            ];

            function findNodeById(id) {
                return nodesData.find(n => n.id === id);
            }

            function renderAll() {
                canvas.querySelectorAll('.sankey-node, .sankey-group-node').forEach(el => el.remove());
                
                nodesData.forEach(nodeInfo => {
                    if (nodeInfo.parent) return;
                    let nodeElement;
                    if (nodeInfo.type === 'group') {
                        nodeElement = createGroupElement(nodeInfo);
                        if (!nodeInfo.isCollapsed) {
                            const children = nodesData.filter(n => n.parent === nodeInfo.id);
                            children.forEach(childInfo => {
                                const childElement = createNodeElement(childInfo);
                                nodeElement.appendChild(childElement);
                                makeDraggable(childElement);
                            });
                        }
                    } else {
                        nodeElement = createNodeElement(nodeInfo);
                    }
                    canvas.appendChild(nodeElement);
                    makeDraggable(nodeElement);
                });

                setTimeout(redrawAllLinks, 0);
            }
            
            function createNodeElement(nodeInfo) {
                const nodeElement = document.createElement('div');
                nodeElement.id = nodeInfo.id;
                nodeElement.className = 'sankey-node';
                nodeElement.style.borderColor = nodeInfo.color;
                
                if(nodeInfo.parent){
                    const childrenOfParent = nodesData.filter(n => n.parent === nodeInfo.parent);
                    const myIndex = childrenOfParent.findIndex(n => n.id === nodeInfo.id);
                    nodeElement.style.position = 'absolute';
                    nodeElement.style.left = `20px`;
                    nodeElement.style.top = `${55 + myIndex * 36}px`; // Espacio m√°s compacto
                } else {
                    nodeElement.style.left = `${nodeInfo.x}px`;
                    nodeElement.style.top = `${nodeInfo.y}px`;
                }

                nodeElement.innerHTML = `
                    <div class="node-icon">${nodeInfo.icon}</div>
                    <div class="node-info">
                        <div class="node-label">${nodeInfo.label}</div>
                        <div class="node-value">${nodeInfo.value?.toFixed(2) || ''} PJ</div>
                    </div>
                    ${createMenuHtml(nodeInfo)}
                `;
                setupMenu(nodeElement, nodeInfo);
                return nodeElement;
            }

            function createGroupElement(nodeInfo) {
                const groupElement = document.createElement('div');
                groupElement.id = nodeInfo.id;
                const children = nodesData.filter(n => n.parent === nodeInfo.id);
                const totalValue = children.reduce((sum, child) => sum + child.value, 0);

                if (nodeInfo.isCollapsed) {
                    groupElement.className = 'sankey-node';
                    groupElement.style.width = '220px';
                    groupElement.innerHTML = `
                        <div class="node-icon">üì¶</div>
                        <div class="node-info">
                            <div class="node-label">${nodeInfo.label}</div>
                            <div class="node-value">${totalValue.toFixed(2)} PJ</div>
                        </div>
                        ${createMenuHtml(nodeInfo)}
                    `;
                } else {
                    groupElement.className = 'sankey-group-node';
                    const height = 45 + children.length * 36 + 15; // Altura ajustada
                    const width = 220; // Ancho ajustado
                    groupElement.style.width = `${width}px`;
                    groupElement.style.height = `${height}px`;
                    groupElement.innerHTML = `
                        <div class="group-title">${nodeInfo.label}</div>
                        <div class="group-total-value">${totalValue.toFixed(2)} PJ</div>
                        ${createMenuHtml(nodeInfo)}
                    `;
                }
                
                groupElement.style.left = `${nodeInfo.x}px`;
                groupElement.style.top = `${nodeInfo.y}px`;
                groupElement.style.borderColor = nodeInfo.color;
                
                setupMenu(groupElement, nodeInfo);
                return groupElement;
            }

            function createMenuHtml(nodeInfo) {
                let menuItems = `
                    <div class="popup-item" data-action="history">Ver hist√≥rico</div>
                    <div class="popup-item" data-action="charts">Ver gr√°ficos</div>
                `;
                if (nodeInfo.type === 'group') {
                    const actionText = nodeInfo.isCollapsed ? 'Expandir' : 'Contraer';
                    menuItems += `<div class="popup-item" data-action="toggle-collapse">${actionText}</div>`;
                }
                 return `
                    <div class="node-add-button" style="background-color: ${nodeInfo.color};">+</div>
                    <div class="node-popup-menu">${menuItems}</div>
                `;
            }
            
            function setupMenu(nodeElement, nodeInfo) {
                const button = nodeElement.querySelector('.node-add-button');
                if(!button) return;

                button.addEventListener('click', e => {
                    e.stopPropagation();
                    const menu = nodeElement.querySelector('.node-popup-menu');
                    const isVisible = menu.classList.contains('visible');
                    closeAllPopups();
                    if (!isVisible) menu.classList.add('visible');
                });
                
                nodeElement.querySelectorAll('.popup-item').forEach(item => {
                    item.addEventListener('click', e => {
                        e.stopPropagation();
                        const action = e.currentTarget.dataset.action;
                        if (action === 'toggle-collapse') {
                            nodeInfo.isCollapsed = !nodeInfo.isCollapsed;
                            renderAll();
                        } else {
                            console.log(`Acci√≥n '${action}' en el nodo '${nodeInfo.id}'`);
                        }
                        closeAllPopups();
                    });
                });
            }

            function closeAllPopups() {
                document.querySelectorAll('.node-popup-menu.visible').forEach(menu => menu.classList.remove('visible'));
            }

            function makeDraggable(element) {
                element.addEventListener('mousedown', onMouseDown);
                function onMouseDown(e) {
                    e.stopPropagation(); // FIX: Previene que el evento se propague al padre
                    if (e.button !== 0 || e.target.closest('.node-add-button')) return;
                    let wasDragged = false;
                    element.classList.add('dragging');
                    const nodeData = findNodeById(element.id);
                    const rect = element.getBoundingClientRect(), canvasRect = canvas.getBoundingClientRect();
                    const offsetX = e.clientX - rect.left, offsetY = e.clientY - rect.top;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);

                    function onMouseMove(e) {
                        wasDragged = true; e.preventDefault(); closeAllPopups();
                        let x = e.clientX - canvasRect.left - offsetX;
                        let y = e.clientY - canvasRect.top - offsetY;
                        element.style.left = `${x}px`; element.style.top = `${y}px`;
                        nodeData.x = x; nodeData.y = y;
                        redrawAllLinks();
                    }
                    function onMouseUp(e) {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        element.classList.remove('dragging');
                        if (!wasDragged) {
                            focusedNodeId = element.id;
                            updateFocus();
                        }
                    }
                }
            }
            
            function getDownstreamFlow(startNodeId) {
                const nodesToVisit = [startNodeId];
                const highlightedNodes = new Set([startNodeId]);
                const highlightedLinks = new Set();
                const startNode = findNodeById(startNodeId);

                if (startNode.type === 'group' && startNode.isCollapsed) {
                    const children = nodesData.filter(n => n.parent === startNodeId);
                    const childIds = children.map(c => c.id);
                    linksData
                        .filter(link => childIds.includes(link.source))
                        .forEach(link => {
                            const linkId = `path-group-${startNodeId}-to-${link.target}`;
                            if (!highlightedLinks.has(linkId)) {
                                highlightedLinks.add(linkId);
                                highlightedNodes.add(link.target);
                                nodesToVisit.push(link.target);
                            }
                        });
                } else {
                    while (nodesToVisit.length > 0) {
                        const currentNodeId = nodesToVisit.shift();
                        linksData
                            .filter(link => link.source === currentNodeId)
                            .forEach(link => {
                                const linkId = `path-${link.source}-to-${link.target}`;
                                if (!highlightedLinks.has(linkId)) {
                                    highlightedLinks.add(linkId);
                                    highlightedNodes.add(link.target);
                                    nodesToVisit.push(link.target);
                                }
                            });
                    }
                }
                return { nodes: highlightedNodes, links: highlightedLinks };
            }

            function updateFocus() {
                const flow = focusedNodeId ? getDownstreamFlow(focusedNodeId) : null;
                const startNode = focusedNodeId ? findNodeById(focusedNodeId) : null;

                document.querySelectorAll('.sankey-node, .sankey-group-node').forEach(el => {
                    el.classList.remove('focused', 'faded');
                    if (flow) {
                        if (flow.nodes.has(el.id)) {
                            el.classList.add('focused');
                        } else {
                            const isParentOfFocused = startNode && startNode.parent === el.id;
                            if (!isParentOfFocused) {
                                el.classList.add('faded');
                            }
                        }
                    }
                });

                svgLinks.querySelectorAll('.sankey-link, .particle').forEach(el => {
                    el.classList.remove('faded');
                    if (flow && !flow.links.has(el.id)) {
                        el.classList.add('faded');
                    }
                });
            }

            function redrawAllLinks() {
                svgLinks.innerHTML = '';
                const virtualLinks = [];
                const groupLinks = {};

                linksData.forEach(link => {
                    const sourceNode = findNodeById(link.source);
                    const parentGroup = sourceNode.parent ? findNodeById(sourceNode.parent) : null;

                    if (parentGroup && parentGroup.isCollapsed) {
                        const key = `${parentGroup.id}->${link.target}`;
                        if (!groupLinks[key]) {
                            groupLinks[key] = {
                                source: parentGroup.id,
                                target: link.target,
                                value: 0,
                                children: []
                            };
                        }
                        groupLinks[key].value += link.value;
                        groupLinks[key].children.push(sourceNode);
                    } else {
                        virtualLinks.push(link);
                    }
                });

                Object.values(groupLinks).forEach(link => virtualLinks.push(link));
                
                const maxValue = Math.max(...virtualLinks.map(l => l.value), 1);
                
                virtualLinks.forEach(linkInfo => {
                    const sourceNodeEl = document.getElementById(linkInfo.source);
                    const targetNodeEl = document.getElementById(linkInfo.target);

                    if (sourceNodeEl && targetNodeEl) {
                        const path = document.createElementNS(SVG_NS, 'path');
                        const isGroupLink = !!linkInfo.children;
                        const pathId = isGroupLink ? `path-group-${linkInfo.source}-to-${linkInfo.target}` : `path-${linkInfo.source}-to-${linkInfo.target}`;
                        
                        path.setAttribute('id', pathId);
                        path.setAttribute('class', 'sankey-link');
                        
                        const maxAllowedWidth = Math.min(sourceNodeEl.offsetHeight, targetNodeEl.offsetHeight) * 0.9;
                        const calculatedWidth = (linkInfo.value / maxValue) * 50;
                        const strokeWidth = Math.min(Math.max(2, calculatedWidth), maxAllowedWidth);

                        path.setAttribute('stroke-width', strokeWidth);
                        path.setAttribute('d', getLinkPath(sourceNodeEl, targetNodeEl));
                        svgLinks.appendChild(path);

                        createParticlesForLink(pathId, linkInfo);
                    }
                });
                updateFocus();
            }

            function getLinkPath(source, target) {
                const canvasRect = canvas.getBoundingClientRect();
                const targetRect = target.getBoundingClientRect();
                let x1, y1;

                if (source.offsetParent && source.offsetParent.classList.contains('sankey-group-node')) {
                    const sourceParentRect = source.offsetParent.getBoundingClientRect();
                    x1 = (sourceParentRect.left - canvasRect.left) + source.offsetLeft + source.offsetWidth;
                    y1 = (sourceParentRect.top - canvasRect.top) + source.offsetTop + source.offsetHeight / 2;
                } else {
                    const sourceRect = source.getBoundingClientRect();
                    x1 = (sourceRect.right - canvasRect.left);
                    y1 = (sourceRect.top - canvasRect.top) + sourceRect.height / 2;
                }

                const x2 = (targetRect.left - canvasRect.left);
                const y2 = (targetRect.top - canvasRect.top) + targetRect.height / 2;
                const controlX1 = x1 + (x2 - x1) / 2;
                return `M ${x1} ${y1} C ${controlX1} ${y1}, ${controlX1} ${y2}, ${x2} ${y2}`;
            }

            function createParticlesForLink(pathId, currentLink) {
                let colorMix = [];
                if (currentLink.children) {
                    colorMix = currentLink.children.map(child => ({ color: child.color, value: child.value }));
                } else {
                    const sourceNode = findNodeById(currentLink.source);
                    colorMix.push({ color: sourceNode.color, value: currentLink.value });
                }
                
                const totalMixValue = colorMix.reduce((sum, mix) => sum + mix.value, 0);
                const particleCount = Math.ceil(Math.log(currentLink.value + 1) * 4);
                const duration = 6 - Math.log10(currentLink.value + 1);

                for (let i = 0; i < particleCount; i++) {
                    let selectedColor = colorMix[0].color;
                    if (totalMixValue > 0) {
                        const randomVal = Math.random() * totalMixValue;
                        let cumulativeValue = 0;
                        for (const mix of colorMix) {
                            cumulativeValue += mix.value;
                            if (randomVal <= cumulativeValue) {
                                selectedColor = mix.color;
                                break;
                            }
                        }
                    }

                    const particle = document.createElementNS(SVG_NS, 'circle');
                    particle.id = pathId;
                    particle.setAttribute('class', 'particle');
                    particle.setAttribute('r', '3.5');
                    particle.setAttribute('fill', selectedColor);
                    
                    const animateMotion = document.createElementNS(SVG_NS, 'animateMotion');
                    animateMotion.setAttribute('dur', `${Math.max(2, duration)}s`);
                    animateMotion.setAttribute('repeatCount', 'indefinite');
                    animateMotion.setAttribute('begin', `${Math.random() * duration}s`);
                    
                    const mpath = document.createElementNS(SVG_NS, 'mpath');
                    mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${pathId}`);
                    
                    animateMotion.appendChild(mpath);
                    particle.appendChild(animateMotion);
                    svgLinks.appendChild(particle);
                }
            }
            
            canvas.addEventListener('click', (e) => {
                if(e.target === canvas) {
                    focusedNodeId = null;
                    updateFocus();
                    closeAllPopups();
                }
            });

            renderAll();
        });
    </script>
</body>
</html>
